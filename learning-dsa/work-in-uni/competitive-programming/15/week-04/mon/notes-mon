имаме функция на който търсим ексремумите.

Ternatry Search
===========
Разделяме интервала на три области.
Нека знаем за всяко х1 и х2  такива, че A <= x1 < x2 <= X  f(x1) < f(x2)
Нека знаем за всяко х1 и х2  такива, че A <= x1 < x2 <= X  f(x1) > f(x2)

https://en.wikipedia.org/wiki/Ternary_search

Има друг начин да се намери това нещо - hill climbing

работи добре ако изберем малка стъпка. Този алгоритъмът работи доста добре за
намиране на глобален максимум. Тя гарантирано ще намери някой глобален максимум.
Стига да не остър има добри шансове да го хване.


Това е за функцията с един аргумент.

f(cur - step)
f(cur + step)

f(x - step, y)
f(x + tep, y)
f(x, y - step)
f(x, y + step)

изреждане на всики възможности

нека имаме масиви

int dx[] = {0 ,1, 0, -1};
int dy[] = {1, 0, 1, 0};

for(i = 0; i < 4; i++)
{
  int newX =  x + dx[i];
  int newY = y + dy[i];
}
Такива масива могат и да се направят и за тримерно. За там добавям още един dz[]

Вече за повече държим координатите в масив.

Първото и по трудно да се направи за повече едно от едномерно
Второто слабо ни интересува за колко.
С тези помощни масиви dx, dy, dz можем да си ги нижем кокото си искаме


Нека имаме
double f(double x)

double epsilon = 1e-8;
int dx [2]={-1, 1}

double hillClimb(double start, double step)
{
  double curVal = f(start);
  while(step > eps)
  {
    int i;
    for(i = 0; i < 2; i++)
    {
      start += step * dx[i];
      double newVal = f(start);
      if(f(start)> curVal))
      {
        curval = newVal;
        break;
      }
      start -= step * dx[i];
    }

    if(i == 2) step/=2;
  }  return start;
}

Шансовете е да е две трети. В случая че има един единственен ексремум.

Трябва да се внимава с double.

Ококоло нулата числата са много надробени. При тях имам 20тина значещи цифри след десетичната запетая.
При големи числа лесно могат да се получат грешки. Защото имаме

Използването на float се пестят ресурси

Основно се ползва double, Long Double.

==========================================

Графи:
===
Видове:
---
- ориентиран неоринтирен
- цикличен ацикличен
- претеглен непретелген
- свързан граф
- силно свързан говорим при ориентиран граф
- слабо свързан

Графи представяне в паметта:
1. матрица на съседство

n  - брой върхове
m  - брой ребра


  {0, 1, 0, 0},
  {1, 0, 0, 0},
  {1, 0, 0, 1},
  {0, 0, 1, 0}}


необходима памет: O(N^2)
проверка дали съществува връх: O(1)
добавяне/ махане O(1)
съседство O(n)
обхождане по ребра  O(n^2)

2. Списък на съседство
к
A -> B, C
B -> A
C -> A, D
D -> C

необходима памет: O(m)
проверка: O(k) като го напрвим логаритъм. Можем да ги пазим в хеш.
добавяне/ махане O(1)
съседство  O(k)
обхождане по ребра  O(n + m)

Важно е да се избере правилния начин за представяне.
На състезания най често се пази с vector. Най удобно е защото е най малко.

k - брой съседи на текущия връх.

най често използваната
vector<vector<int>> v;
с векторите е много лесно да се направи
ne.clear();
ne.resize();


3. списък на ребрата:
необходима памет: O(m)
проверка дали съществува връх: O(m)
добавяне/ махане O(1)
съседство O(m)
обхождане по ребра  O(m)

В паметта най често като vector от pair<int, int>

(0,1),(0,2),(2,3)
