Knapsack problem
======

Рекурсивно
----

Раница със вместимост M килограма.
Имаме N предмета всеки един със тегло и цена.
Кой е най голямата стойност.

Примерно решение е да се вземат оптималните цена върху тегло.



| weight | price  |
| ------ |:----   |
| 3      | 3      |
| 5      | 8      |
| 6      | 19     |

Всичките възможни комбинации са 2^N
Да един милион е OK


В типовете задачи, които се дават е до хиляда 2^1000 e много за да се сметне
Ако видим задача с до 1000 правим динамично

подзадачата
с първите k и обем на раницата l каква ще е цената

```
//Сложността на реализацията е n ^ 2 * m
int dyn[1<<10][1<<10]
// k -  първите k предмета, които подаваме
// w - остналия обем
int rec(int k, int m)
{
  if(k == 0) return 0;
  if(m == 0) return 0;
  if(dyn[k][m] != -1) return dyn[k][m]; // връщаме каква е най голямата стояност която се получава
  int res = 0;// тук пазим коя е най добрата цена, която можем да вземем
  for(int i = 0; i < k; i++) // разглеждаме първите k предмета,
    if(weight[i] < m)//ако тежестта на i-тия предмет се събира в раницата го вземаме и проверяме за
      res = max(res, rec(i, w - weight[i]) + price[i]);
  return dyn[k][m] = res;
}
```

Може да се направят оптимизация. Без да използваме дадена
Трябва да я извикаме със rec(N, M)
Всичките предмети със целия обем
Граничен случай:
 * нямаме повече премдмети k = 0 връщаме 0
 * нямаме повече обем w = 0, връщаме 0

Определянето на броя на дименциите на диманичното става като се преброят броят на
аргументите на рекурсивната финк;ия



Оптимизация - махаща n^2
```
//Сложността на реализацията е n ^ 2 * m
int dyn[1<<10][1<<10]
// k -  първите k предмета, които подаваме
// w - остналия обем
int rec(int k, int m)
{
  if(k == 0) return 0;
  if(m == 0) return 0;
  if(dyn[k][m] != -1) return dyn[k][m]; // връщаме каква е най голямата стояност която се получава
  int res = rec(k - 1, w);
  if(weight[k-1] <=  w)
    res = max(res, rec( k - 1, w - weight[k - 1]) + price[k-1]);
  return dyn[k][w] = res;
}
```

Същата задача с повторение
Махаме изваждането на k - 1 и го заменяме със k

```
//Сложността на реализацията е n ^ 2 * m
int dyn[1<<10][1<<10]
// k -  първите k предмета, които подаваме
// w - остналия обем
int rec(int k, int m)
{
  if(k == 0) return 0;
  if(m == 0) return 0;
  if(dyn[k][m] != -1) return dyn[k][m]; // връщаме каква е най голямата стояност която се получава
  int res = rec(k - 1, w);
  if(weight[k-1] <=  w)
    res = max(res, rec( k , w - weight[k - 1]) + price[k-1]);
  return dyn[k][w] = res;
}
```

Пример
----

1. Нека всички предмети имат еднаква тежест
Input: capacity = 20, objects[n] = { 2 3 5 7 9};

| 0 | 1 | 2 | 3 | 4 |
| ----------------- |
| 2 | 3 | 5 | 7 | 9 |


Итеративно
----
Рекурсивното обикновено е по лесно за измисляне.
То най често е опиасние нана задачата.
Чрез него можем да си изведем и итеративното решенеи
Също такаможем да видим с какво да попълним началните клетк ще попълним от дъното на рекурсията.


(k, w)

(k - 1, w)  (k - 1 , w - weight[k-1]) + C
```
int dyn[2][1<<17];
int main()
{
  memeset(dyn, 0, sizeof(dyn)); // пълним го с нули
  // пускаме по редове на въображамата ни таблица, но реално ще пазим само два
  for(int i = 0; i <= n; ++i) // вървим по всеки ред, всяка итерация по този for е един ред в нашата таблица
  {
    int cur = i % 2; //тукущия ни ред
    int prev = 1 - cur; //предишния ред
    dyn[cur][0] = 0; // попълваме нулата, затова цикъла по j започва по i
    for(int j = 1; j = 1; j++)
    {
      dyn[cur][j] = dyn[prev][j];
      if(weight[i - 1] <= j)
        dynn[cur][j] = max(dynn[cur][j]), dynn[prev][j - weight[i - 1]] + price[i - 1]);
    }
  }
  dyn[n%2][w];
}


Некй имаме едномерно масив
2 3 5 7'



| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
| --- | --- | --- |
| -1 | 2 | -1| -1| -1| -1| -1| -1| -1| -1| -1| -1|
| -1 | -1| -1| -1| -1| -1| -1| -1| -1| -1| -1| -1|


| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
| --- | --- | --- |
| 0 | 2 | 3 | -1| -1| -1|1(00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) -1| -1| -1| -1| -1| -1|
| 0 | 3 | 3 | -1| -1| -1| -1| -1| -1| -1| -1| -1|


 Можем да ги попълваме отзад напред.
