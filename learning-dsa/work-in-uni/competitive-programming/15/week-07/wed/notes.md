Задача за търговския пътник.

Хамилтонов е път който съдържа всички върхове точно веднъж.
Задачата е NP пълна.
Няма друг начин да намерим дали един път е хамилтонов цикъл освен ако не го проверим

Пускаме едно ДФС и запомняме кои  обходен.

Това dfs има сложност n!
'''
used[N];
int count;
bool found = false;
void dfs(int v)
{
  used[v] = true;
  count++;
  for(int i = 0; i < ne[v].size; i++)
  {
    int nv = ne[v][i];
    if(!used[nv])
      dfs(nv);

    if(nv == 0 && count == n))
      found true;
  }
  used[v] = false;
  count--;
}
```
Инетересува ни дали сме обходили всички върхове.
Това може да го представим по следния



Сега ще отимизираме и ще направим динамично за решаване на проблема
short dyn[5][6][32]
short dyn[5][6][2][2][2][2][2]

първата дименция е в кой връх сме
втората дименция колко върха сме обходили
третата дименция през кои върхове сме мнили

Де факто втората дименция ни е излишна защото можем да изчислим

01001 -> отбелязали сме 0 и 3 като обходени
00100 -> отбелязали сме 2 като обходен

Ако искаме да преверим дали к-тия връх е използван, трябва да проверим дали к-тия бит е вдигнат.
Това става като направим побитови (t &  (1 << k)) == 0  значи k-тия връх е изпозлзван.
Друг начин да направим това е (t >> k)
лото 32 може да се представи в паметта с пет значещи единици

```
//p - дали родителя е обходен
//помним count за да не изчисляваме всеки път
//used[2] = true;
char dyn[20][1<<20], p[20];
bool dfs(int v, int count, int mask)
{
  if(dyn[v][mas] != -1) return dyn[v][mask];
  char &res = dyn[1][mask] ; res = 0;
  mask |= (1<<v);
  int res = 0;
  count++;
  for(int i = 0; i < ne[v].size;++i)
  {
    int nv = ne[v][i];
      if((mask&(1<<nv)) == 0)
      {
        bool cur = dfs(nv);
        if(cur)
        {
          res = 1;
          p[nv] = v;
          break;
        }
      }
      if (nv ==0 && count == n)
      {
        res = 1;
        p[nv] = v;
        break;
      }
  }
  //count няма нужда да го пременяме, не е голабална променлива
  masl & =(~(1<<v));
  return res;
}
```

Битовите маски може да се използват в много задачи, където имаме 2 състояния
