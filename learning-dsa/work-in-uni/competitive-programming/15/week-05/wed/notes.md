Floyd - Warshall
Това алгоритъм, който е доста удобен да се напрви със мтрициа на съседство.

алгоритъмът има сложност O(V^3), където V е броя на върховете

a[i][j] - > тежестта на реброто.
Ако няма, тогава е безкрайност.
Алгоритъмът работи добре и с отрицателни числа.

const int INF = (1 << 27)

инварианта е твърдение валидно на всяка стъпка на алгоритъма


int dist[][];
int a[1000][1000];

int next[i][j]; // обновявем го на всяка стъпка, когато променяме пътя

void floyd-warshall()
{
  for(....) // copy a -> dist по
    for(...) //  инициализираме върха.
  for(int l = 0; k < n; ++k) // използваме върхове от 0..k за да проверим дали
    for(int i = 0; i < n; ++i)  //
      for(int j = 0; j < n; ++j) //
        if(dist[i][j] > dits[i][k] + dist[k][j]) // значи, че сме намерили по добро разстояние от i до j
        {
          dist[i][j] = dits[i][k] + dist[k][j];
          next[i][j] = next[i][k];;
          next[j][j] = next[i][k];;
        }    

}

Идеята е че имаме два върха. i - j
Ако няма ребро, това ще е нашата безкрайност.

i      j
*------*
 \    /
   *
   k

Пробелемът е че не знаем как сме стигнали.
Дейкстра не работи с отрицателни цикли. Този работи.
Дейкстра строи дърво на минималните пътища.
Флойд намира всички пътища.

Какво правим ако искаме да намерим пътя?

За да си пазим пътя, трябва да добавицм да добавим родителя.

next[i][j]= j;
как си възстановяваме пътя?

vector<int> path(i, j)
{
  if(dist[i][j]!=INF)
  {
    vector<int> v'
    v.push_back(i);
    do
    {
      i = next[i][j];
      v.push_back(i);
      while(i!=j);
      return v;
    }
  }
  return vector<int>();
}


Bellman -Ford

подобен на Дейкстра. Има с една идея по голяма сложност, но от друга страна върши работа при графи с отрицателна дължина.
Алгоритъмът не е greedy

Дейкстра взема един връх и строи Минимално покриващо дърво от него. Прилича на алгоритъма на Прим

Белман форд
Върви по всички ребра. Прави на всяка стъпка нещо като алгоритъма на Флойд.
int dist[];
dist[start] = 0;
dist[start] = INF;
dist[i] + w(i,j) < dist[j];

В случая най удобното представяне е списък на ребрата.
Ако имаме списък на съседите ще сложим и един цикъл.

Инварианта
Всичко минимални пътища с дължина до к ще са вече в  dist

Почваме всички ребра

vector<Edge> e;
void Bellman-frod(int start)
{
  //init dist
  for(int k = 1; k < n; k++) // въртим по всички ребра, където n ни е броя на върховете
    for(int t = 0; t < e.size(); t++)
    {
        int i = e[t].start
        int j = e[t].end;
        int w = e[t].weight;
        if(dist[i] + w < dist[j])
          dist[j] = dist[o + w;
          parent[j]=i;

    }
}

Белман форд се изпова при отрицаелни ориентиран върхове.
Белман Форд е със worst case(n.m)
Дейкстра имаме worst case (n*n). Но ако си напише правилно се пише със  O (n log m)

отрицателен цикъл има тежест отрицателно число. Ако него го зациклим до безкрай ще има проблем.
Лошо е да имаме отрицателни цикли. Може само ребрата да са отрицателни.

Силни свързани компаноненти - от всеки може да се стигне до всеки
=================
Целта е да върнем вектор от вектори.

Tarjan's strongly connected components algorithm
Правим едно бфс по случайно избран връх. В момента в който влезем в някой връх го добавяме в един стек.
Инварианта е
За всеки връх пазим относителен индекс, който представялава номера на оббхождането, кой подред е този връх. Всеки следващ връх му слагаме номер по индеск. Всеки връх ще пази едно число, което представлява минималния индекс на връх до който можем да се стигне.

2 3 5

Най доброто представяне е списък на съседите

int index[M], low_link[M], stack[], top;
bool inStack[]
vector<vector<int>> ne;
void tarjan(int v)
{
// ред 3           2          1
  index[v] = low_lin[v]= next++;
  inStack[v] = true;
  stack[top++] = ;
  for(int i = 0; i < ne.size(); ++i)
  {
    int nv = nr[v][i];
    if(index[nv]==-1) // все още не сме го обхождали
    {
      tarjan(nv);
      low_link[v] = min(low_link[nv], low_link[v])
    }else if(inStack[nv])
      low_link[v] = min(low_link[v], low_link[nv])
  }

  if(index[v] == low_link[v])
  {
    vector<int> comp;
    while(top > 0)
      int t = stack[top--];
      comp.push_back(t);
      if(t==v) breaK;
  }
  scc.push_back(comp);
  }
}

int main()
{
  for(int i = 0; i < n; i++)
  {
    if(index[i] == -1) tarjan(i);
  }
}
====
другия алгоритъм пуска просто две дфс-та,
в графа. Запазва само единия индекс
Идеята, че пускаме дфс и след

 void dfs(int v)
 {
   for(int i = 0; i < ne[v].size(); ++i)
   {
     int nv= ne[v][i];
     if(!inStack[nv])
     dfs(nv);
    }
    stack[top++] = v;
    inStack = true;
 }


транспониране на граф
 for(i = 0; i < n; i++)
 {
   for(j = 0; J < ne[i].size(); ++j)
   {
     revne[ne[i][j]].push_back(i);
   }
   }
 }



void tarjan(int )кофитите е че

vector < vector < pair <int, double > > > ne;
cin>>n;
ne.clear();
ne.resize(n);
cin>>a>>b>>w;
ne[a].push_back(make_pair(b, w));
ne[b].push_back(make_pair(a, w));
