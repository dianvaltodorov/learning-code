int dyn[410][410];

вместо да гледаме първите N знака ще гледаме знаците в някакъв интервал
Затова ще ни трябва двумерен масив. Отговориът ни се намира в dyn[0][n-1]

необходима е рекурсивна финкция
int (int a, int b)
Викаме я с
```
int rec(0 , n-1)
{
  if(a == b) return 1; // това е заслучай
  if(a > b) return 1;
  if(dynn[a][b] != -1) return dyn[a][b];
  {

  }
}
```
В началото гледаме от началото до края.
[1;  n - 1]
rec (a, b) -> max [ rec(a + 1, b), rec(a, b + 1), if(s[a] == s[b]) 2 + rec(a + 1, b -1)]
Дължината на най дългия палиндром ще е същата
   0   1   2   3   4   5   6   7   8   9  10  11  12   13   14   15  16
0  0   0   0   0   0   0   0   0   0   0   0   0   0    0    0    0   0
1
2
3     
4
5
6
7
8
9
10
11
12
13
14
15
16
