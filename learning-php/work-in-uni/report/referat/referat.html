<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="./css/dracula.css">
  <script src="./javascript/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <title>Clojure</title>
</head>
<body font-family:"Source Sans Pro">

  <div style="width:800px;margin-left: auto;margin-right: auto;">
    <h1 style="text-align: center;font-family:"Source Sans Pro"">Функционални езици в уеб: Clojure</h1>
    <img src="img/logo.png" alt="Clojure logo" style="width:304px;display: block;margin-left:auto;margin-right:auto;">
    <div id="Intro">
      <h2>Intro</h2>
      <article id="overview">
        <hgroup>
          <h3>Какво е Clojure</h3>
        </hgroup>
        <p>Clojure представлява динамичен програмен език с общо предназначение. Целта му е да комбинира достъпността и интерактивността на един скриптов език със ефективността и силата на изградена вече друга платформа(JVM). Също така в езика са широко застъпено многонишково програмиране. Clojure се компилира, но е дновременно с това остава напълно динамичен, като всяка функционалност се поддържа по време на изпълнение. Доставая се пълен достъп до всички Java библиотеки. Също така clojue e диалект на Lisp и се придъжра към приниципите за код като данни и макро систамата. Самият език е предимно функционален и се основава на богати immutable persistant структури от данни.</p>
        <p>В днешно време има изключително много софтуерни системи, опериращи върху JVM. Едновременно клиенти и различни стейкхолдъри са удовлетворени от производителността, сигурността и стабилността на опериращият върху тази платформа(JVM) код. Често Java програмистите обаче завиждат на гъвкавостта, изразителността и продуктивността на динамичните езици. В допълнение, по време на работа те трябва да се грижат и за съвместимост с досега изписания код и външни библиотеки, адаптиране към вече изградената екосистема. Не бива да се забравят и множеството проблеми със справянето със нишките и локовете. Clojure e опит за изготвяне на прагматичен динамичен език именно в този контекст. Той се опитва да бъде general-purpose език, удобен в сфери, където Java е удачен избор. Рефлектира концепцията, според която в името на конкурентното бъдеще, проникваща, неуправляема мутираща трябва да си тръгне.</p>
        <p>Clojure се справя с поставените си цели, като се придържа към стандарти от индустрията и ползва отворената платформа на JAVA виртуалната машина. Също така модернизира Lisp езика и ползва неговите изразителност. Възползва от идеята за immutability. Резултатът е бърз, практичен и удобен език за програмиране.</p>
      </article>

      <article id="history-of-the-langauge">
        <hgroup>
          <h3>История на езика</h3>
        </hgroup>
        <p>Създателят на езикът се казва Rich Hickey. Преди да изготвянето му той е разработвал dotLisp, което е подобен проект с разликата, че е базиран на .Net. По преди се е занимава и с други проекти, които целят да предоставят съвместимост между Java и Lisp. Авторът прекарва приблизително 2 години и половина работейки над проекта преди да го пусне, като през цялото време работи изключително върху езика без да разчита на външно финансиране. В края на този период той изпраща имейл на хора в обществото, с които споделя за съществуването му. Целия процес на разработка при езика се движи от обществото и се управлява от Clojure Community сайта.</p>
      </article>
    </div>

    <div id="big-ideas">
      <h2>Големите идеи на езика</h2>
      <article id="big-ideas-of-the-langauge-overview">
        <hgroup>
          <h3>Големите идеи на езика</h3>
        </hgroup>
        <ul>
          <li>Lisp</li>
          <li>Функционален стил на програмиране</li>
          <li>Симбиоза с устоновена и стабилна платформа</li>
          <li>Изготвен с идеята за конкуренто програмиране предвид</li>
        </ul>
      </article>

      <article id="why-lisp">
        <hgroup>
          <h3>Защо Lisp</h3>
        </hgroup>
        <ul>
          <li>Ламбда смятането подсигурява изключително малко и изразително ядро. Ламбда смятането се явява се теоритичната математическата обосновка на функционалното програмиране. То езключително удобен и практичен изчислителен модел.</li>
          <li>Почти никакъв синтаксис. Самият език има малък на брой конструкции, с чиято помощ лесно могат да бъдат изразени желаните идеи.</li>
          <li>Предимства пред стандартния Lisp(Common Lisp и Scheme):
            <ul>
              <li>В стандартния Lisp почти никакви или бавни нововъдения и разработки след стандартизацията.</li>
              <li>В стандартния никакви спецификации, свързани с конкурентостта.</li>
              <li>Стандартните Lisp-ове са си собствена платформа.</li>
            </ul>
          </li>
          <li>Clojure е Lisp, който поддържа обратна съвместимост:
            <ul>
              <li>Усъвършенства парадигмата за code-as-data с добавянето на maps и vector-и.</li>
              <li>Разчита на immutability. Тоест веднъж инициализирани, данните не се променят никога.</li>
              <li>    азчита на immutability. Тоест веднъж инициализирани, данните не се променят никога.</li>
            </ul>
          </li>
        </ul>
      </article>

      <article id="why-functional">
        <hgroup>
          <h3>Защо функционално програмиране</h3>
        </hgroup>
        <ul>
          <li>First-class functions - за един език това означава, че функциите се третират като first-class citizens. Тоест функциите могат да бъдат подавани като аргументи, да бъдат върнати стойности, да се присвояват на променливи или да се съхраняват в различни структури от данни.</li>
          <li>Винаги може да се направи на Lisp.Според тезисът на Чърч, според който всички изичисилтелни модели(функционалния и императивния) са еквивалентни.</li>
          <li>Pure funcitonal често са силно типизирани. Строгата типизация е хубаво и лошо нещо. Clojure e динамичен език с акцент върху динамичното програмиране:
            <ul>
              <li>Всички структури от данни в езика са immutable и persistant.</li>
              <li>Хетерогенни колекции и върнати типове .</li>
              <li>Динамичен полиморфизъм.</li>
            </ul>
          </li>
        </ul>
      </article>

      <article id="programming-languages-and-platforms">
        <hgroup>
          <h3>Програмни езици и платформи</h3>
        </hgroup>
        <p>Виртуалните машини са платформите на бъдещето. Ползите които те предоставят са много:  </p>
        <ul>
          <li>Типова система e система решава голям брой проблеми. Така нареченото type safety се отнася за това до каква степен програмния език предотвратява типови грешки.</li>
          <li>Пада се олекотена абстракция над операционната система.</li>
          <li>Управлението на паметта и зачистване на ресурсите.</li>
          <li>Garbage colector-a е платформа, не е част от езика.</li>
          <li>Байткодът + Just in time compilation е начин за абстракция над хардуера.</li>
          <li>Език като платформа срещу език + платформа. В миналото всеки език дефинира своя собствен runtime в това число garbage collctor,  bytecode, type system, библиотеки. Новияя начин за правене на нещата се базира на оползотворяването на завършени платформи от рода на JVM и .Net</li>
          <li>Много от новите езици използват стария подход, като започват да изграждат цяла нова платформа. Когато се наложи port-ване между различни платформи има проблеми.</li>
          <li>Платформите се  задават от клиентите. Често като бизнес условие се казва, трябва да върви на JVM, трябва да върви на .NET.</li>
          <li>Сама по себе си JAVA е език и платформа. Тя доста често пъти е неизразителна, функциите не са first class citizens.Решението е JVM  платформата , а Clojure е езикът</li>
        </ul>
      </article>

      <article id="oop">
        <hgroup>
          <h3>Обектно ориентираното програмиране е прехвалено</h3>
        </hgroup>
        <p>То се ражда на базата на симулации и се използва навсякъде дори, когато е неуместно. Окуражава се от Java/C# поради бедната им идиоматична поддръжка. Mutable обектите да новия спагети код, защото са трудни за разбиране, тестване, и обработка. Има големи проблеми със поддръжката на конкурентен код.</p>
        <p>Наследяването не е единственият начин да се правиполиморфизъм. Важи правилото, че е по-добре да има 100 функции, които оперират върху една структура от данни, наместо 10 функции, опериращи върху 10 стуктиру от данни.</p>
        <p>Clojure моделира даните като immutable обекти, представени чрез своите интерфейси, и в друг случай не предоставя своя класова система.</p>
        <p>Писането става на Java, но може и дас е пише на Clojure.</p>
      </article>

      <article id="polymorhism">
        <hgroup>
          <h3>Полиморфизмът е хубаво нещо</h3>
        </hgroup>
        <p>Полиморфизмът в обектно ориентираното програмиране представлява свойството на обектите от един и същи тип да имат един и същи интерфейс, но с различна реализация на този интерфейс. Въпреки, че е функционален clojure активно възползва от принципите на полуморфизма. Смисълът на полиморфизма може да бъде накратко изразен със следната фраза - "Един интерфейс, множество от различни реализации". Чрез полиморфизма се постига по-голяма абстракция и по-лесно повторно използване на кода. Полиморфизмът е причина да има лесни за модификация, гъвкави системи. Методите в clojure разграничава принципите на обектно ориентираният дизайн и полиморфизъм. </p>
      </article>

      <article id="concurency">
        <hgroup>
          <h3>Многонишково програмиране</h3>
        </hgroup>
        <p>Днешните системи се налага да се справят с множество едновременни задачи. Необходимо е да се оползотвори мощността на многоядрени процесори. Тази задача определено е нелека. Използването на множество нишки е изключително трудно следствие на проблемите, които възникват, заради синхронизацията. Clojure опростява значително многонишковите програми по няколко начина. Тъй като данните са immutable, те лесно могат да бъдат споделяни между нишките. Въпреки това, често е необходимо да има променящо се състояние в една програма. Езикът clojure се явява практично и елегантно решение на редица проблеми. Той позволява промяна на състояния, но осигурява  механизъм, чрез който се подсигурява, консистентност, като облекчава разработчиците от обгрижването на различни локове. Целия език подсигурява лесно споделяне на промени между отделните нишки по един асинхронен и независим начин. Важно е да се отбележеи, че clojure не замества нишкките в Java. По скоро цели да работи с тях.</p>
      </article>

      <article id="dynamic-type-system">
        <hgroup>
          <h3>Динамично типизиране</h3>
        </hgroup>
        <p>На първо място Clojure e динамично типизиран. Това означава, че една Clojure програма не e просто нещо, което се компилира и изпълнява. По скоро представлява нещо динамично, с което може да се взаимодейства. Clojure сам по себе си не е абстракция, реализирана чрез програмен език, а повече среда, където почти всички програмни конструкции са навързани и могат да бъдат изследвани и проучвани. Резултатът е възможността за се дописва, да се разширява и променя една програма в един непрекъснат поток.</p>
      </article>
    </div>

    <div id="repl">
      <h2>REPL и примери</h2>
      <article id="basics">
        <hgroup>
          <h3>Базови конструкции</h3>
        </hgroup>

        <div class=snippent id="comments">
          <p>Коментарите започват с точка и запетая. Lieur</p>
          <pre><code>
; This is a comment.
; The first call in a file should be ns, to set the namespace
(ns learnclojure)
          </code></pre>
        </div>

        <div class=snippent id="comments">
          <p>На clojure се пише с помощта на форми, които представляват списък, ограден със скоби и с празни интервали между отделните елементи. Очаква се първият елемент на този списък да е функция или макро, а следващите да са аргументи. Елементарните аритметични операции и булеви сравнения се извършват по следния начин:</p>
          <pre><code class="dracula">
(+ 1 1) ; => 2
(- 2 1) ; => 1
(* 1 2) ; => 2
(/ 2 1) ; => 2

; Equality is =
(= 1 1) ; => true

; Comparisons:
(< 2 3) ; => True
(> 2 3) ; => False
          </code></pre>
        </div>

        <div class=snippent id="classes">
          <p>Clojure използва Java обектите на Java за булеви изрази, числа и стрингове. Тяхната проверка се осъществява с помощта на class</p>
          <pre><code>
(class 1) ; Integer literals are java.lang.Long by default
(class 1.); Float literals are java.lang.Double
(class ""); Strings always double-quoted, and are java.lang.String
(class false) ; Booleans are java.lang.Boolean
(class nil); The "null" value is called nil
          </code></pre>
        </div>

        <div class=snippent id="litarals-and-evalutions">
          <p>В clojure лесно могат да бъдe създаван списък литерал. Това напомня стандартния Lisp начин и става с помощта на символа '. В случай, че е необходимо даден списък литарал да бъде оценен, се използва форвмата eval</p>
          <pre><code>
(quote (+ 1 2))) ; => (+ 1 2)
;with a shorthand (+ 1 2)

; You can eval a quoted list
(eval '(+ 1 2)) ; => 3
          </code></pre>
        </div>
      </article>


      <article id="colls-and-seqs">
        <hgroup>
          <h3>Collections and Sequences</h3>
        </hgroup>
        <div class=snippent id="colls-and-seqs-overview">
          <p>Списъците в clojure са структури от данни, реализирини отдолу със свързан списък. От друга страна вектоите са разчитат на масиви.</p>
          <pre><code>
(class [1 2 3]); => clojure.lang.PersistentVector
(class '(1 2 3)); => clojure.lang.PersistentList
; A list would be written as just (1 2 3), but we have to quote
; it to stop the reader thinking it's a function.
; Also, (list 1 2 3) is the same as '(1 2 3)
          </code></pre>
        </div>

        <div class=snippent id="colls-and-seqs-overview">
          <p>Модифициране на колекциия е оптимизирано. Формата conj би добавила елемнт към списъка по възможно най оптималния начин. При списъците, това е в началото, а при векторите, в края.</p>
          <pre><code>
(conj [1 2 3] 4) ; => [1 2 3 4]
(conj '(1 2 3) 4) ; => (4 1 2 3)
          </code></pre>
        </div>

        <div class=snippent id="colls-and-seqs-overview">
          <p>Конкатенирането също става лесно.</p>
          <pre><code>
(concat [1 2] '(3 4)) ; => (1 2 3 4)
          </code></pre>
        </div>
        <div class=snippent id="colls-and-seqs-overview">
          <p>Функции от по висок ред.</p>
          <pre><code>
; Use filter, map to interact with collections
(map inc [1 2 3]) ; => (2 3 4)
(filter even? [1 2 3]) ; => (2)

; Use reduce to reduce them
(reduce + [1 2 3 4])
; = (+ (+ (+ 1 2) 3) 4)
; => 10

; Reduce can take an initial-value argument too
(reduce conj [] '(3 2 1))
; = (conj (conj (conj [] 3) 2) 1)
; => [3 2 1]
          </code></pre>
        </div>
      </article>

      <article id="functions">
        <hgroup>
          <h3>Функции </h3>
        </hgroup>
        <div class=snippent id="create-functions">
          <p>Създаването на функции става с помощта на fn. Върната стойност е последно оцениния израз.</p>
          <pre><code>
(fn [] "Hello World") ; => fn
; (You need extra parens to call it)
((fn [] "Hello World")) ; => "Hello World"
          </code></pre>
        </div>
        <div class=snippent id="variables">
          <p>Декларирането на променливи става с с помощта на формата def. Тъй като функциите са първокласни граждани и могат да бъдат присвоявани на променливи. Цялата констрикция може да бъде съкратена удобно чрез defn. Извикването става, чрез ограждане в скоби.</p>
          <pre><code>
(fn [] "Hello World") ; => fn

; (You need extra parens to call it)
((fn [] "Hello World")) ; => "Hello World"

; Assign a function to a var
(def hello-world (fn [] "Hello World"))
(hello-world) ; => "Hello World"

; You can shorten this process by using defn
(defn hello-world [] "Hello World")

; You can have multi-variadic functions, too
(defn hello3
([] "Hello World")
([name] (str "Hello " name)))
(hello3 "Jake") ; => "Hello Jake"
(hello3) ; => "Hello World"
          </code></pre>
        </div>
      </article>

      <article id="data-structures">
        <hgroup>
          <h3>Структури от данни</h3>
        </hgroup>
        <div class=snippent id="maps">
          <h4>Maps</h4>
          <p>В clojure има два вида maps. Единият е Hash map, другият array maps. Те споделят един и същ интерфейс. Разликата произтича от това, че hash map-овете не гарантират ред. Осъществянето на достъп става, чрез ключови думи или литерал. Те са дефинирани в езика по особен начин</p>
          <pre><code>
(class {:a 1 :b 2 :c 3}) ; => clojure.lang.PersistentArrayMap
(class (hash-map :a 1 :b 2 :c 3)) ; => clojure.lang.PersistentHashMap

(class :a) ; => clojure.lang.Keyword

(def stringmap {"a" 1, "b" 2, "c" 3})
stringmap  ; => {"a" 1, "b" 2, "c" 3}

(def keymap {:a 1, :b 2, :c 3})
keymap ; => {:a 1, :c 3, :b 2}

; Retrieve a value from a map by calling it as a function
(stringmap "a") ; => 1
(keymap :a) ; => 1
          </code></pre>
        </div>

        <div class=snippent id="sets">
          <h4>Sets</h4>
          <p>В clojure също така има set. Върху тях също могат да се изпълняват редица операции. Сред тах са обединение, проверка за съществувавне и други.</p>
          <pre><code>
(class #{1 2 3}) ; => clojure.lang.PersistentHashSet
(set [1 2 3 1 2 3 3 2 1 3 2 1]) ; => #{1 2 3}

; Add a member with conj
(conj #{1 2 3} 4) ; => #{1 2 3 4}

; Remove one with disj
(disj #{1 2 3} 1) ; => #{2 3}

; Test for existence by using the set as a function:
(#{1 2 3} 1) ; => 1
(#{1 2 3} 4) ; => nil
          </code></pre>
        </div>

        <div class=snippent id="rationals">
          <h4>Рационални числа</h4>
          <p>Рационалните числа са представени по следния начин 22/3. Върху тях лесно се осъществат матемитически операции. Особеното е при сравнията.</p>
          <pre><code>
(ratio? 22/7)
;; => true

(ratio? 22)
;; => false

(ratio? 2.2)
;; => false

(= 3/2 1.5)
;; => false

(== 3/2 1.5)
;; => true
          </code></pre>
        </div>

        <div class=snippent id="keywords">
          <h4>Ключови думи</h4>
          <p>Ключовите думи са символни идентификатори, които се оценяват.</p>
          <pre><code>
(keyword 'foo)
:foo

(keyword "foo")
:foo

(keyword "user" "foo")
:user/foo

;; keyword in current namespace
(keyword (str *ns*) "foo")
:user/foo
          </code></pre>
        </div>
      </article>
    </div>

    <div id="clojure-script">
      <h2>ClojureScript(компилатор за Clojurе, таргетиращ Javascript)</h2>
      <article id="javascript-reach">
        <hgroup>
          <h3>Javascript Reach</h3>
        </hgroup>
        <p>Има много среди(например браузъри), за които Javascript е единствената програмируема технология. От друга страна има и други, (например mobile платформите), където Javascript е най-преносимият и лесен за адаптация подход при разработка. Javascript е широко използван като продължение на останалите скриптови езици, като разширение. </p>
      </article>

      <article id="javascript-unstable">
        <hgroup>
          <h3>Javascript не е стабилен</h3>
        </hgroup>
        <p>Дори и поддръжниците на Javascript не могат да не се съгласят с недостатъците му. Има много тъмни ъгли в семантиката на езика. Не е стегнат, добре организиран и подходящ за мета програмиране или разширение. Най притеснителното е че писането на стабилни и качествени програми изискват сериозна дисциплина и строго спазване на конвенции. Проблемът в случая е, че конвенциите се различават между отделните общества и библиотеки.</p>
      </article>

      <article id="app-client-server">
        <hgroup>
          <h3>Приложенията от типа client – service постоянно се разрастват</h3>
        </hgroup>
        <p>Първоначалната употреба на Javascript ie e състояла в добавянето на интерактивност към  html сайтове. Предназначението на езика е било да оживи в известна степен статистичните html документи. В днешно време Javascript  се появяват навсякъде. Той се превръща в ключов логически, информационен и UI компонент от една система. Подобни приложения поставят високи изисквания към своите модули задвижвани от Javascript. </p>
      </article>

      <article id="js-engines">
        <hgroup>
          <h3>Javascript engine-ите набират сили</h3>
        </hgroup>
        <p>От Javascript се очаква да прави повече и повече. Следствие на това, Javascript engine-ите се променят от простички интерпретатори към сложни високопроизводителни платформи, които генерират native код, и имплементират  класически и нови оптимизации от динамичните езици.</p>
      </article>

      <article id="google-makes-the-way">
        <hgroup>
          <h3>Google проправя път</h3>
        </hgroup>
        <p>Google предоставят изключително много от технологията, необходима за реализацията на тази Javascript революция. Те са отговорни за създаването на V8 JS engine-a, Closure библиотеката и Closure компилаторът. Google е отворила кода на голяма част от тази своя технология.</p>
      </article>

      <article id="library-problems">
        <hgroup>
          <h3>Проблемът с библиотеките</h3>
        </hgroup>
        <p>Много от приложенията трябва да правят все повече неща. Следствие се налага добавянето на по-големи и по-големи библиотеки. Проблем в това е, че таргетираните платформи са с ограничени ресурси- малко памет, връзка с интернет. Има постоянно напрежение да се намали размерът на кода. Минификацията сама по себе си не е достатъчна в много от случаите. Полученият резултати не са достатъчно добри. От друга страна, приложенията рядко използват всичката включена функционалност. Открива се възможност за оптимизация, която се състои в това да се намали да се включи само и единствено използвания код. Така ще се получат значителни подобрения и редукции. Тази стратегия се ползва именно от двойката Google Closure library и Google Closure compiler.</p>
      </article>

      <article id="closure-compiler">
        <hgroup>
          <h3>Closure Compiler</h3>
        </hgroup>
        <p>Компилира Javascript кода към компактен, високопроизводителен код. Самия компилатор премахва мъртвия и неизползван код, пренаписва и минимизира каквото е останало, така, че да е лесен и бърз за сваляне. Също така проверява синтаксис, референции към променливи, типове и предупреждава за недостатъци в кода. По този начин се позволява писането на по леки, по-лесни за поддръжка приложения, които и се поддържат по-лесно.</p>
      </article>

      <article id="closure-library">
        <hgroup>
          <h3>Closure Library</h3>
        </hgroup>
        <p>Самата Closure бибиотека е широка, добре изтествана, модулярна и достъпна през всички браузъри библиотека. От нея може да се вземе само необходимото без да се налага да се включва останалия код. Включеното се състои в широк набор от лесни за преизползване UI компоненти и контроли до инструменти от ниско ниво за DOM манипулации, сървърни комуникации, анимации, структури от данни, unit тестване и така нататък.</p>
      </article>
    </div>

    <div id="clojure-web-development">
      <h2>Clojure Web Development</h2>
      <article id="overview">
        <hgroup>
          <h3>Overview</h3>
        </hgroup>
        <p>При Clojure няма доминиращ web framework. Не е като при другите езици, където се дава завършена и самостоятелна рамка, с която може да се работи. Примери се падат за Ruby Sinatra или Rails, за Python Django и Flask и така нататък. Също така няма и ангажиращи парадигми, като при Javascript, където има Ember.js, Angular.js, където всеки framework налага свой изцяло нов поглед върху разработката. При  Clojure се спазва мантрата "Leave data alone.", която произтича от идеята, че всичко се базира на immutable структурите от данни. Всяка една от характеристиките на clojure е достъпна на всяка стъпка.</p>
      </article>

      <article id="overview">
        <hgroup>
          <h3> Какво е нужно за web разработката и защо? </h3>
        </hgroup>
        <ul>
          <li>Web server/ http абстракция</li>
          <li>Middleware</li>
          <li>Сесии</li>
          <li>Csrf защита</li>
          <li>Request routing</li>
          <li>Html tamplating</li>
          <li>Authentication</li>
          <li>Database abstraction</li>
          <li>Frontend комуникация</li>
        </ul>
      </article>
    </div>
    <div id="clojure-web-development">


      <article id="overview">
        <hgroup>
          <h3>Clojure библиотеки</h3>
        </hgroup>
        <ul>
          <li>Http abstraction – Ring</li>
          <li>Middleware – Ring</li>
          <li>Routing – Compojure</li>
          <li>HTML Templating – Hiccup/ Enlive</li>
          <li>Authentication – Friend</li>
        </ul>
      </article>


      <div id="ring">
        <h2>Ring</h2>
        <article id="ring-overview">
          <hgroup>
            <h3>Overview</h3>
          </hgroup>
          <p>Ring представлява Clojure web application  библиотека, вдъхновена от питонския WSGI и рубиски Rack, пърлския Plack. Целта е да се извърши абстракция над детайлите около HTTP протоколите. Резултатът е унифицирано API, което позволява лесна уеб разработка. Получава се модулярни компонент, който лесно може да бъде споделян между множество други приложения, сървъри или рамки за разработка. В прости термини, Ring се занимава с всичките дребни и особени детайли около имплементацията на HTTP заявките и отговорите, параметрите, бисквитките и прочие. Така се спестява low-level детайлите и се развързват ръцете на разработчиците. Тази абстракция e просто интерфейс между сървърите и приложението. </p>
          <p>В Ring се засягат следните основни концепции</p>
          <ul>
            <li>Handler</li>
            <li>Request</li>
            <li>Response</li>
            <li>Middleware</li>
          </ul>
        </article>

        <article id="ring-handlers">
          <hgroup>
            <h3>Handlers</h3>
          </hgroup>
          <p>Handler-ите представляват функции, които дефинират едно уеб приложение. Те приемат един аргумент, map, представляващ HTTP заявка и връщат други map, явяващ се HTTP отговор.</p>
        </article>

        <article id="ring-requests">
          <hgroup>
            <h3>Requests</h3>
          </hgroup>
          <p>Както беше споменато HTTP заявките представляват Clojure maps. Има множество стандартни ключове, които винаги ще съществуват, но заявките съдържат и редица части ключове, идващи от middleware-a. Тези стандартни ключове включват:</p>
          <ul>
            <li>:server-port - порта, на който ще бъде обработена заявката </li>
            <li>:server-name - името на сървъра или IP адреса на сървъра </li>
            <li>:uri – URI-то от заявкатаъд </li>
            <li>:content-type – MIME типът на request тялото </li>
            <li>:content-length - брой байтове в тялото на request-a </li>
            <li>:character-encoding -  името на encoding-a, използван в тялото, ако се знае.</li>
          </ul>
        </article>

        <article id="ring-response">
          <hgroup>
            <h3>Response</h3>
          </hgroup>
          <p>Отговорът също е map. Той съдържа три основни ключа:</p>
          <ul>
            <li>:status - HTTP статус код 200,302, 404 и така нататък</li>
            <li>:headers – clojure map от HTTP хедъри, където стойностите може да бъдат стрингове,.</li>
            <li>:body - съдържанието на тялото.</li>
          </ul>
        </article>

        <article id="ring-middleware">
          <hgroup>
            <h3>Middleware</h3>
          </hgroup>
          <p>Middleware добавя допълнителна функционалност за  различните handler-и. Първият аргумент за една middleware функция трябва да е handler, а върната стойност трябва да е нова handler функция, която би извикала оригиналната фукция.</p>
          <pre><code>
(defn wrap-content-type [handler content-type]
(fn [request]
(let [response (handler request)]
(assoc-in response [:headers "Content-Type"] content-type))))
          </code></pre>
        </article>
      </div>


      <div id="Compojure">
        <h2>Compojure</h2>
        <article id="compojure-overview">
          <hgroup>
            <h3>Какво е Compojure</h3>
          </hgroup>
          <p>Compojure е малка библиотека, която позволява създаването на спецфични request handlers за конкретни URL  </p>
        </article>

        <article id="compojure-first-steps">
          <hgroup>
            <h3>Създаване на прост route</h3>
          </hgroup>
          <ol>
            <li>Отворете своя .clj файл.</li>
            <li>Дабавете следния код:
              <pre><code>
(defroutes home-routes
(GET "/" [] (home-page))
(GET "/about" [] (about-page))
(ANY "/req" request (str request)))
              </code></pre>
            </li>
            <li>Стартирайте Ring сървъра</li>
            <li>Посетете http://localhost:3000/req .</li>
          </ol>
        </article>
      </div>

      <div id="Compojure">
        <h2>Compojure</h2>
        <article id="compojure-overview">
          <hgroup>
            <h3>Какво е Compojure</h3>
          </hgroup>
          <p>Compojure е малка библиотека, която позволява създаването на спецфични request handlers за конкретни URL  </p>
        </article>

        <article id="compojure-first-steps">
          <hgroup>
            <h3>Създаване на прост route</h3>
          </hgroup>
          <ol>
            <li>Отворете своя .clj файл.</li>
            <li>Дабавете следния кодМ
              <pre><code>
(defroutes home-routes
(GET "/" [] (home-page))
(GET "/about" [] (about-page))
(ANY "/req" request (str request)))
              </code></pre>
            </li>
            <li>Стартирайте Ring сървъра</li>
            <li>Посетете http://localhost:3000/req .</li>
          </ol>
        </article>
      </div>

      <div id="Friend">
        <h2>Friend</h2>
        <article id="friend-overview">
          <hgroup>
            <h3>Какво е Friend</h3>
          </hgroup>
          <p>Friend представлява разширение на библиотеката Ring, което служи за аутентикация и оторизация. Самата библиотека е много стабилна и се използва широко в production среда.</p>
          <ul>
            <li>аутентикация на потребители, http, OpenId аутентикация.</li>
            <li>Канална сигурност.</li>
            <li>Дефинира скоуп на аутентикация, оторизация и канална сигурност</li>
            <li>Хеширане</li>
            <li>Чисто функционален.Данните от аутентикации, роли, сесии се подават като обикновени persistant данни. Няма запазено състояние при сесиите и е значително улеснен целия процес на разработка.</li>
          </ul>
        </article>
      </div>

      <div id="conclusion">
        <article id="last-words">
          <hgroup>
            <h3>Заключение</h3>
          </hgroup>
          <p>Clojure се развива изключително бързо. По природа представлява динамичен програмен език с общо предназначение. Комбинира достъпността и интерактивността на един скриптов език със ефективността и силата на изградена вече платформа(Java виртулната машина). Застъпено функционалното и многонишково програмира. Clojure се намира там където Lisp среща Java вселената.</p>
          </article>
      </div>
      <div id="resource">
        <article id="resource-list">
          <hgroup>
            <h3>About</h3>
          </hgroup>
            Диан Тодоров, 61670
        </article>
      </div>

      <div id="resource">
        <article id="resource-list">
          <hgroup>
            <h3>Източници</h3>
          </hgroup>
          <ul>
            <li>
              https://clojure.org/
            </li>
            <li>
              https://github.com/ring-clojure/ring/wiki
            </li>
            <li>
              https://github.com/weavejester/compojure/wiki
            </li>
            <li>
              https://github.com/cemerick/friend
            </li>
            <li>
              https://www.youtube.com/watch?v=_LghX4oDWcY
            </li>
            <li>
              http://www.amazon.com/Clojure-Development-Essentials-Ryan-Baldwin/dp/1784392227
            </li>
          </ul>
        </article>
      </div>
    </div>
  </body>
  </html>
