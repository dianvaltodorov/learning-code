 ﻿<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="css/bootstrap.css" rel="stylesheet"></link>
		<link href="css/bootstrap-responsive.css" rel="stylesheet"></link>
		<link href="css/site.css" rel="stylesheet"></link>

		<script src="javascript/prettify.js" type="text/javascript"></script>
		<script src="javascript/angular.min.js" type="text/javascript"></script>
        <script src="javascript/lodash.js" type="text/javascript"></script>
		<script src="directives/scDirectives.js" type="text/javascript"></script>
		<script src="directives/scNav.js" type="text/javascript"></script>
		<script src="directives/scDocument.js" type="text/javascript"></script>
	</head>
	<body onload="prettyPrint()">
		<div ng-app="scDirectives">
			<div class="container">
                <sc-document nav-menu="true">
                    <article id="overview">
                        <hgroup>
                            <h2>Какво са директивите?</h2>
                        </hgroup>
                        <p>Директивите са една от най-вълнуващите функционалности на AngularJS, тъй като са нещо специфично за Angular. Възможността да създаваш преизползваеми библиотеки от компоненти, които могат да бъдат използвани в приложенията като чист HTML е нещо изключително мощно и AngularJS единствен предоставя това на уеб разработчиците.</p>
                        <p>Съществуват няколко JavaScript продукти, които предлагат контроли за уеб приложенията. Например Bootstrap е една доста популярна front-end библиотека, която предоставя стилове за различните HTML елементи, както и някои JavaScript компоненти. Проблемът при тях е, че за да използва тези компоненти, програмистът трябва да премине в JavaScript режим и да напише някакъв JQuery код за да активира въпросните компоненти.</p>
                        <p>Директивите в Angular представляват маркери върху DOM елементите (като например атрибут, име на елемент или CSS клас), които казват на HTML компилатора на AngularJS (<code>$compile</code>), да приложи указаното поведение върху DOM елемента или дори да го трансформира по определен начин заедно с неговите деца.</p>
                    </article>
                    <article id="compiler">
                        <hgroup>
                            <h2>Малко за HTML компилатора на AngularJS</h2>
                        </hgroup>
                        <p>HTML компилатора на AngularJS позволява на програмистите да научат браузъра на нов HTML синтаксис. Това се постига като се свързва определено поведение с даден HTML елемент или атрибут или дори чрез създаването на нови HTML елементи или атрибути – всичко това чрез директивите.</p>
                        <p>
                            Компилаторът е Angular преглежда DOM-а, търсейки атрибути. Компилационният процес се състои от две фази:
                            <ol>
                                <li>Compile: преглежда DOM-а, събирайки всички директиви. Резултатът от това е свъзраща функция.</li>
                                <li>Link: комбинира директивите с област, в резултат на което се получава определен изглед. Всички промени в модела на областта се отразяват в изгледа и всяко взаймодействие на потребителя с изгледа се отразява в модела на областта. По този начин моделът се превръща в SSOT (single source of truth).</li>
                            </ol>
                        </p>
                        <p>Имайки предвид това, директивите в AngularJS могат да бъдат определени като поведение, което трябва да бъде задействано когато определени HTML конструкции биват срещнати по време на компилационния процес.</p>
                    </article>
                    <article id="dirCompilation">
                        <hgroup>
                            <h2>Как Angular третира директивите?</h2>
                        </hgroup>
                        <p>
                            Ще разгледаме как HTML компилатора на Angular определя кога да използва определена директива. Нека разгледаме следния HTML код:
                            <code class="prettyprint"> &ltinput ng-model=”foo” /&gt </code>.
                            В този случай казваме, че <code>&ltinput&gt</code> елементът отговаря на <code>ngModel</code> директивата. Всъщност, това можем да кажем и за следващия пример:
                            <code class="prettyprint"> &ltinput data-ng:model=”foo” /&gt </code>
                        </p>
                        <p>Angular нормализира тага на елемента и името на атрибута, за да определи кои елементи на кои директиви съответстват. Стилът за описване на директиви задава тяхното име да е във формат camelCase (за нашия пример - <code>ngModel</code>). Но тъй като HTML по принцип не отчита големи и малки букви, в него директивите се реферират чрез използването на тире като разделител между отделните думи (<code>ng-model</code>).</p>
                        <p>
                            Процесът по нормализация следва следните стъпки:
                            <ol>
                                <li>Премахване на x- и data- от началото на елементите или атрибутите.</li>
                                <li>Превръщане на :, - или _ разделителите в camelCase.</li>
                            </ol>
                        </p>
                        <p>
                            <code>$compile</code> може да разпознава директиви, описани като име на елемент, атрибут, име на клас или коментар. Всички вградени в Angular директиви могат да бъдат използвани чрез който и да е от четирите подхода:<br>
                            <pre class="prettyprint"><code> &ltng-model&gt&lt/ng-model&gt <br/> &ltspan ng-model=”expr”&gt&lt/span&gt <br/> &lt!—- directive: ng-model expr --&gt <br/> &ltspan class=”ng-model: expr;”&gt&lt/span&gt </code></pre>
                        </p>
                        <p>По принцип е препоръчително да се използват директивите чрез задаване на tag име или име на атрибут пред това чрез коментари или име на клас. Съображенията за това са, че кодът става по-четим и е по-лесно за хората да определят, че въпросният елемент е всъщност директива.</p>
                        <p>Директивите, зададени като коментар бяха доста често използвани в ситуации, когато създаването на директиви, които се прилагат върху много елементи (например в <code>&lttable&gt</code> елементи) има известни ограничения. AngularJS 1.2 въведе новите <code>ng-repeat-start</code> и <code>ng-repeat-end</code> като разрешение на този проблем.<p>
                        <p>
                            Компилацията на HTML се случва в 3 фази:
                            <ol>
                                <li><code>$compile</code> претърсва DOM-а и открива директивите. Ако компилаторът открие, че даден елемент съответства на някоя директива, то тази директива се добавя към списъка с директиви, съответстващи на DOM елемента.</li>
                                <li>Веднъж след като всички директиви, съответстващи на DOM елемента са идентифицирани, компилаторът сортира директивите по техния приоритет.<br>За всяка директива се изпълнава нейната <code>compile</code> функция, която има шанса да модифицира DOM-а. Всяка <code>compile</code> фунцкия връща <code>link</code> функция. Тези две функции се комбинират в една комбинирана свърваща функция.</li>
                                <li><code>$compile</code> свързва темплейта с областта чрез извикването на комбинираната свързваща функция от предната стъпка.</li>
                            </ol>
                        </p>
                    </article>
                    <article id="dirCreation">
                        <hgroup>
                            <h2>Създаване на директиви</h2>
                        </hgroup>
                        <p>
                            Първо ще видим как точно се регистрират директивите. Доста подобно на контролерите, директивите се регистрират в модули, като за целта се използва следният синтаксис: <code> module.directive</code>
                        </p>
                        <p>
                            <code>module.directive</code> приема като параметри нормализираното име на директивата, последвано от <code>factory</code> функция. <code>Factory</code> функцията се извиква само веднъж когато компилаторът срещне директивата за първи път. Всичкият код, свързан с инициализационната логика, следва да бъде сложен точно тук.
                        </p>
                        <p>Съществуват много и най-различни опции за една директива. Разликата между отделните директиви се крие в това, което връща <code>factory</code> функцията, тъй като именно тя оказва на <code>$compile</code> как директивата следва да бъде третирана. Тази функция може да върне или Directive Definition Object, или просто <code>postLink</code> функция, като в този случай всички останали свойства ще имат стойности по подразбиране.</p>
                        <p>
                            Сега ще разгледаме различните свойства, които може да има обекта, върнат от <code>factory</code> функцията:
                            <ul>
                                <li>
                                    <strong>priority</strong><br>
                                    Когато имаме много директиви, дефинирани върху един DOM елемент, понякога имаме нужда да окажем реда, в който тези директиви трябва да се приложат. Свойството <code>priority</code> представлява число, което се използва за сортиране на директивите преди техните <code>compile</code> функции да бъдат извикани. Директивите с по-висок приоритет биват компилирани преди тези с по-нисък. <code>Pre-link</code> функциите също биват извиквани в ред на приоритета им, докато <code>post-link</code> – в обратен. Стойността по подразбиране за това свойство е 0.
                                </li>
                                <li>
                                    <strong>scope</strong><br>
                                    <u>При зададена стойност true</u>, за директивата ще бъде създадена нова област. Ако няколко директиви, дефинирани върху един и същ елемент изискват нова област, то само една такава ще бъде създадена.<br>
                                    <u>При зададена стойност { }</u>, ще бъде създадена нова изолирана област. „Изолираната“ област се различава от нормалната по това, че не наследява прототипно от областта на своя родител. Това е доста полезно когато се създават преизползваеми компоненти, които не трябва да четат или да модифицират информация в областта на своя родител. Въпреки това, в повечето случаи директивата ще трябва да има достъп до някои от свойствата в областта на своя родител. Това може да бъде осъществено чрез задаването на свойства в scope обекта. Тези свойства могат да имат следните стойности:
                                    <ul type="square">
                                        <li>@ или @attr – свързва свойство от локалната област със стойността на DOM атрибута. Резултата от това винаги е низ, тъй като DOM атрибутите са низове. Ако <var>attr</var> името не е споменато, то името на атрибута се очаква да бъде същото като локалното име. Когато в областта на родителя свойството с упоменатото име се променя, това ще рефлектира в промяна на свойството в локалната област. Обратното не е вярно.</li>
                                        <li>= или =attr – създава двупосочна връзка между свойството в локалната област и това в областта на родителя. Това означава, че когато в областта на родителя въпросното свойство се променя, тази промяна ще се отрази и в свойството в локалната област, както и обратното.</li>
                                        <li>& или &attr – осигуряват начин да се изпълни даден израз в контекста на областта на родителя. Това позволява на директивите да изпълнят някакво действие, различно от това просто да променят стойността на дадено свойство.</li>
                                    </ul>
                                    Всички тези локални свойства се наследяват по описания начин от областта на родителя. За тази цел просто описание в <code>scope</code> свойството на директивата не е достатъчно – DOM елементът трябва да има съответния атрибут със зададеното име, за да може директивата да останови необходимите връзки. Например, нека предположим, че в областта на родителя имаме свойство <var>parentProp</var>. Тогава следното описание на директивата:
                                    <code class="prettyprint">&ltdir my-directive&gt</code>
                                    при положение че my-directive има област:
                                    <code class="prettyprint">scope: { localProp: ‘@parentProp’ }</code>
                                    няма да резултира в свързване на <var>localProp</var> със стоийността на <var>parentProp</var> в родителя.<br>
                                    За да може това да се случи, директивата трябва да е описана по следния начин:
                                    <code class="prettyprint">&ltdir my-directive the-parent-prop=”parentProp”&gt</code>
                                    , като областта на директивата е зададена по следния начин:
                                    <code class="prettyprint">scope: { localProp: ‘@theParentProp’ }</code>.<br>
                                    Сега нека предположим, че имаме следната директива:
                                    <pre class="prettyprint"><code>angular.module('directives').directive('my-directive', function() {
    return {
        restrict: 'EA',
        replace: false,
        link: function (scope, element, attrs) {
            scope.someIsolateProp = "I'm isolated";
        },
        scope: {
            interpolatedProp: ‘@interpolated’,
            twowayBindingProp: ‘=twowayBinding’
        }
    };
});</code></pre>
                                    и в HTML-а директивата е използвана по следния начин:
                                    <pre class="prettyprint"><code ng-non-bindable>&ltmy-directive interpolated=”{{parentProp1}}” twowayBinding=”parentProp2”&gt</code></pre>
                                    В този случай, връзката между областта на директивата и тази на нейния родител, може да бъде представена графично по следния начин:<br>
                                    <img class="img-responsive" src="img/26_01_scope.jpeg"></img>
                                </li>
                                <li>
                                    <strong>controller</strong><br>
                                    Контролерът представлява функция, която се извиква преди pre-linking фазата и се споделя между всички директиви от този тип, като това позволява на директивите да комуникират помежду си.  Аргументите, които приема са както следва:
                                    <ul type="square">
                                        <li><var>$scope</var> – текущата област, свързана с елемента</li>
                                        <li><var>$element</var> – текущият елемент</li>
                                        <li><var>$attrs</var> – обект, който съдържа текущите атрибути на елемента</li>
                                        <li><var>$transclude</var> – transclude функцията, свързана с правилната област</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>require</strong><br>
                                    Указва, че директивата се нуждае от друга директива. Контролерът на въпросната директива се предава като четвърти аргумент на свързващата функция (link function). <code>Require</code> приема низ, който представлява име на директивата, която да бъде предадена. В случай, че директивата има нужда от повече от една друга директива, на <code>require</code> се подава масив от низове, като инжектираният аргумент ще представлява масив от контролери в съответния ред. Имената на директивите, от които една директива има нужда, може да бъде префикснато с:
                                    <ul type="square">
                                        <li>(без префикс) – контролерът се търси в текущия елемент. Хвърля се грешка ако такъв не бъде намерен.</li>
                                        <li>? – опитва се да намери въпросния контролер. Ако такъв не е намерен, се праща <var>null</var> към <code>link</code> функцията.</li>
                                        <li>^ – контролерът се търси в родителите на текущия елемент. Ако такъв не е намерен, се хвърля грешка.</li>
                                        <li>?^ – контролерът се търси в родителите на текущия елемент и ако такъв не е намерен, се праща <var>null</var> към <code>link</code> функцията.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>restrict</strong><br>
                                    Определя как директивата ще се използва в HTML-а. Валидните стойности са:
                                    <ul type="square">
                                        <li>'А': атрибут (стойност по подразбиране),</li>
                                        <li>'E': елемент,</li>
                                        <li>'C': клас,</li>
                                        <li>'М': коментар</li>
                                    </ul>
                                    Възможно е задаване на няколко от тези стойности, например 'АE', като в този случай директивата ще може да се използва и като елемент, и като атрибут в зависимост от предпочитанията на конкретния й ползвател.
                                </li>
                                <li>
                                    <strong>template</strong><br>
                                    Заменя текущия елемент със съдържанието на това свойство (, което трябва да е валиден HTML код). В процеса на замяна, всички атрибути и класове от стария елемент се прехвърлят към новия. Стойността на това свойство може да е низ или функция, която приема 2 аргумента – <var>Element</var> и <var>tAttrs</var> и връща низ.
                                </li>
                                <li>
                                    <strong>templateUrl</strong><br>
                                    Има същата функция като <code>template</code>, само че новото описание на елемента се зарежда от зададения URL. Тъй като зареждането на темплейта а асинхронна операция, фазите на компилиране и свързване се отлагат докато той се зареди. Аналогично на <code>template</code>, неговата стойност може да е стринг или функция. При по-големи темплейти, тази опция е за предпочитане пред предходната, тъй като води до по-четим код.
                                </li>
                                <li>
                                    <strong>replace</strong><br>
                                    Определя дали темплейтът на директивата ще замени оригиналния елемент или ще бъде добавен към него. Стойността по подразбиране е <var>false</var>, което запазва оригиналния елемент.
                                </li>
                                <li>
                                    <strong>transclude</strong><br>
                                    При задаване на стойност <var>true</var>, компилира съдържанието на елемента, правейки го достъпно за директивата. Обикновено се използва в комбинация с <code>ngTransclude</code>. Съдържанието на директивата ще бъде в нова изолирана област, като <code>$parent</code> свойството от областта на директивата и от областите на нейните деца ще сочи към една и съща област. Всъщност, когато имаме едновременно изолирана и трансклудната област, свойството на изолираната област <code>$nextSibling</code> ще представлява референция към трансклуднатата област. Нека представим всичко това графично, като за целта приемем, че my-directive директивата, описана по-горе има зададено <code class="prettyprint">trasnclude: true</code><br>
                                    <img class="img-responsive" src="img/26_02_transclude.jpeg"></img>
                                </li>
                                <li>
                                    <strong>compile</strong><br>
                                    В тази функция се извършват трансформации на темплейта на елемента. Тази функция се използва доста рядко, тъй като повечето директиви нямат нуждата да извършват такива трансформации. Пример за директиви, които използват <code>compile</code> функцията са <code>ngView</code> и <code>ngRepeat</code>. <code>Compile</code> функцията има следната сигнатура:
                                    <code class="prettyprint">function compile(tElement, tAttrs) { ... }</code>
                                    , като аргументите й са както следва:
                                    <ul type="square">
                                        <li><var>tElement</var> (template element) – елементът, върху който директивата е била дефинирана. Безопасно е да се модифицират темплейтите единствено на елемента и на неговите деца.</li>
                                        <li><var>tAttrs</var> (template attributes) – нормализиран списък от атрибутите, дефинирани върху елемента.</li>
                                    </ul>
                                    <code>Compile</code> функцията може да връща стойност, която трябва да е или функция, или обект:
                                    <ul type="square">
                                        <li>връщането на <code>post-link</code> функция е еквивалентно на регистрирането на свързваща функция чрез <code>link</code> свойството на обекта, когато <code>compile</code> функцията е празна.</li>
                                        <li>връщането на обект, притежаващ свойства <code>pre</code> и <code>post</code> със стойност функция, позволява контрол върху това кога свързващата функция ще бъде извикана по време на свързващата фаза. </li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>link</strong><br>
                                    Това свойство се използва, само когато <code>compile</code> свойството не е дефинирано. Стойността на <code>link</code> свойството е функция със следната сигнатура:<br>
                                    <code class="prettyprint">function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }</code><br>
                                    <code>Link</code> функцията се изпълнява след като темплейтът е бил клониран. Именно тук се намира повечето от логиката на директивата.
                                    <ul type="square">
                                        <li><var>scope</var> – областта, която ще се използва от директивата за регистриране на watches.</li>
                                        <li><var>iElement</var> (instance element) – елементът, върху който се използва директивата. Децата на елемента е безопасно да бъдат манипулирани само в <code>postLink</code> функцията, когато те вече са свързани.</li>
                                        <li><var>iAttrs</var> (instance attributes) – нормализиран списък от атрибутите, дефинирани върху този елемент. Този списък е един и същ за всички свързващи функции на директивата.</li>
                                        <li><var>controller</var> (controller instance) – инстанция на контролера, ако поне една директива върху елемента дефинира контролер. Контролерът се споделя от всички директиви, което им позволява да комуникират помежду си чрез него.</li>
                                        <li><var>transcludeFn</var> – <code>transclude</code> функцията, свързана с правилната област на действие. Тази функция приема опционален първи параметър, който може да зададе нова стойност на областта.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>pre-linking function</strong><br>
                                    Изпълнява се преди децата на директивата да бъдат свързани. В тази функция не е безопасно да се прави трансформация на DOM елемента, тъй като свързващата функция на компилатора няма да успее да намери правилните елементи за свързване.
                                </li>
                                <li>
                                    <strong>post-linking function</strong><br>
                                    Изпълнява се след като децата на директивата са вече свързани. Тук вече е безопасно да се извършва модификация на DOM.
                                </li>
                            </ul>
                        </p>
                    </article>
                    <article id="dirDocument">
                        <hgroup>
                            <h2>Директива за документ</h2>
                        </hgroup>
                        <p>
                            В тази секция ще създадем директивата <code>sc-document</code>, представляваща документ, която има атрибут <code>nav-menu</code>. Ако този атрибут има стойност <var>true</var>, то документът ще има навигационно меню, насочващо потребителя към дадена тема от документа. Нега сега разгледаме обектът, връщан от тази директива:
                            <pre class="prettyprint"><code>{
    restrict: 'E',
    replace: true,
    transclude: true,
    scope: {
        navMenu: '@'
    },
    compile: DocumentCompile,
    template: '&ltdiv class="row"&gt' +
                  '&ltsc-nav nav-list="navList" class="col-lg-2 col-md-3 col-sm-3 hidden-phone menu" ng-if="navMenu"&gt' +
                  '&lt/sc-nav&gt' +
                  '&ltsection ng-transclude&gt' +
                  '&lt/section&gt' +
              '&lt/div&gt'

};</code></pre>
                        </p>
                        <p>
                            Този обект ни казва няколко неща:
                            <ol>
                                <li>директивата следва да бъде използвана единствено като елемент</li>
                                <li>при наличието на атрибут <code>nav-menu</code> със стойност <var>true</var>, тя създава <code>sc-nav</code> директива с атрибут <code>nav-list</code>, съдържащ стойността на локалното свойство <var>navList</var>.</li>
                                <li>при компилация се извиква функцията <code>DocumentCompile</code></li>
                            </ol>
                        </p>
                        <p>
                            <pre class="prettyprint"><code>function DocumentCompile (tElement, tAttrs) {
    var section = angular.element(tElement.find('section')[0]);
    if (tAttrs.navMenu === 'true') {
        section.attr('class', 'col-lg-8 col-lg-offset-4 col-md-8 col-md-offset-4 col-sm-8 col-sm-offset-4');
    }

    return DocumentLink;
}</code></pre>
                            Тази функция прави 2 неща:
                            <ol>
                                <li>при наличието на атрибут <var>navMenu</var> със стойност <var>true</var>, задава на съдържанието на документа определени CSS класове, които намалят неговата ширина при различните резолюции, така че да не се застъпва с навигационното меню</li>
                                <li>връща <code>link</code> функцията</li>
                            </ol>
                        </p>
                        <p>
                            <pre class="prettyprint"><code>function DocumentLink ($scope, $element) {
    if (!$scope.navMenu) {
        return;
    }

    var articles = $element.find('article');
    $scope.navList = [];

    angular.forEach(articles, function (article) {
        $scope.navList.push({
            name: angular.element(article).find('h2')[0].textContent,
            id: article.id,
            selected: false
        });
    });

    angular.element($window).bind("scroll", function() {
        var screenTop = $window.pageYOffset,
            screenBottom = $window.innerHeight + $window.pageYOffset,
            visibleOnScreen,
            currentArticle;

        visibleOnScreen = _.filter(articles, function (article) {
          return article.offsetTop >= screenTop &&
                 article.offsetTop < screenBottom ||
                 article.offsetTop <= screenTop &&
                 article.offsetHeight + article.offsetTop >= screenBottom;
        });

        currentArticle = _.first(visibleOnScreen);
        if (currentArticle) {
            $scope.navList.map(function (elem) {
                elem.selected = false;
            });

            var currentNavItem = _.find($scope.navList, function (navItem) {
              return navItem.id == currentArticle.id;
            });

            currentNavItem.selected = true;
            $scope.$digest();
        }
    });
}</code></pre>
                            Тази функция намира всички елементи <code>&ltarticle&gt</code>, които са деца на <code>&ltsc-document&gt</code> директивата и на базата на тях конструира <var>navList</var> списъка, съдържащ обекти, които имат свойства:
                            <ul>
                                <li><var>name</var> – заглавието на статията,</li>
                                <li><var>id</var> – нейното id</li>
                                <li><var>selected</var> – булева стойност, показваща дали това е текущо гледаната статия.</li>
                            </ul>
                            Този списък се използва от <code>sc-nav</code> директивата, която ще разгледаме след малко.<br>
                            След това <code>DocumentLink</code> функцията се регистрира за scroll event-a на прозореца, като когато той настъпи се определя коя е текущата статия и на съответстващия й обект в <var>navList</var> списъка се задава стойност <var>true</var> на свойството <var>selected</var>.
                        </p>
                        <p>
                            Най-накрая ще разгледаме и <code>sc-nav</code> директивата. Тази директива връща следния обект:
                            <pre class="prettyprint"><code ng-non-bindable>{
    restrict: 'E',
    replace: true,
    scope: { navList: '=' },

    template: '&ltdiv&gt' +
                  '&lta ng-repeat="nav in navList" ' +
                     'ng-class="{ selected: nav.selected}"' +
                     'ng-click="select(nav)"$gt' +
                       '{{nav.name}}' +
                   '&lt/a&gt' +
              '&lt/div&gt',
    link: NavLink
};

</code></pre>
                            , който определя , че:
                            <ol>
                                <li>директивата следва да се използва като HTML елемент</li>
                                <li>тя очаква атрибут <code>nav-list</code>, който свързва чрез двупосочна връзка със свойството в <code>sc-document директивата</code>. Благодарение на тази връзка промените, които правим в <code>sc-document</code> директивата при настъпване на събитието „скролване“ се отразяват и в <code>sc-nav</code> директивата.</li>
                                <li>директивата създава <code>&lta&gt</code> елементи, които съответстват на обектите в <var>navList</var> списъка. Текстът на тези елементи се взима от <var>name</var> свойството на обекта, а при кликване върху тях се извиква функция с име <var>select</var>, на която се подава като единствен аргумент  обектът, който представлява <code>&lta&gt</code> елемента. Ако някой от обектите в списъка има стойност <var>true</var> за свойството <var>selected</var>, то му се прилага CSS класът selected.</li>
                            </ol>
                        </p>
                        <p>
                            <code>NavLink</code> функцията, реферирана в горния обект, изглежда по следния начин:
                            <pre class="prettyprint"><code>function NavLink ($scope) {
    $scope.select = function (nav) {
        if (nav.selected === true) {
            return;
        }

        $scope.navList.map(function (elem) {
            elem.selected = false;
        });
        nav.selected = true;

        $location.hash(nav.id);
        $anchorScroll();
    }
}</code></pre>
                            Единственото, което прави <code>NavLink</code> функцията е да дефинира select функцията, използвана от <code>&lta&gt</code> децата на <code>sc-nav</code> директивата.
                        </p>
                        <p>
                            <code>Sc-document</code> директивата беше използвана за направата на тази HTML страница, така че читателят да може да види резултата от нейното прилагане.
                        </p>
                    </article>
                    <article id="dirsWhy">
                        <hgroup>
                            <h2>Защо да създаваме собствени директиви?</h2>
                            <p>Тъй като AngularJS директивите са доста полезни и не толкова трудни за писане, много хора вече са насочили своите усилия в това да създават директиви за някои от по-популярните библиотеки. Например, AngularJS екипът вече е създал доста директиви за Bootstrap, наречени UI Bootstrap, ComponentOne  въвежда свои AngularJS директиви с Wijmo библиотеката и има доста директиви, написани за jQueryUI.</p>
                            <p>Но, след като има толкова много източници на вече създадени директиви, какъв е смисълът да се учим как да ги създаваме самите ние? Ето няколко причини за това:</p>
                            <ol>
                                <li>
                                    <strong>Може да имате нужда от някакъв специфичен компонент</strong><br>
                                    Нека си представим за момент, че работим за някоя финансова компания, която използва определен вид форма в много приложения. Формата може да бъде имплементирана като grid с някаква специфична функционалност, като например да сваля данните по определен начин, да променя и валидира данните и да изпраща промените обратно към сървъра. В повечето случаи едва ли някой, извън нашата фирма, ще има нещо, което да задоволи тези нужди. Но за сметка на това, ние можем да си напишем собствена директива, която да бъде на разположение на всички HTML разработчици в нашия екип и която ще спести доста HTML код, позволявайки им да напишат нещо подобно:
                                    <pre class="prettyprint"><code>&ltbody ng-app=”abcFinance”&gt
	&lth3&gtOffshore Investment Summary&lt/h3&gt
	&ltabc-investment-form
		customer=”currentCustomer”
		country=”currentCountry”&gt
	&lt/abc-investment-form&gt
&lt/body&gt</code></pre>
                                    <code>abcInvestmentForm</code> директивата може да бъде използвана в доста приложения, осигурявайки консистентност на кода. Директивата може да бъде лесно поддържана и обновявана, така че да отговаря на новите бизнес практики и изисквания със съвсем малко усилия.
                                </li>
                                <li>
                                    <strong>Може би директивата, от която имаш нужда още не съществува</strong><br>
                                    Може би се е случило така, че си харесал дадена библиотека, за която още никой не е написал директиви и нямаш възможност да чакаш повече. Или може би не харесваш директивите, които си намерил или искаш някакво подобрено подобие на тях.
                                </li>
                            </ol>
                        <hgroup>
                    </article>
                </sc-document>
            </div>
        </div>
    </body>
</html>
