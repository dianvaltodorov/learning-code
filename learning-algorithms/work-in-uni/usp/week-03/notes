Задача 1:p_sort:

binary_search(v.begin(), v.end(), val)
binary_search(a, a + N, val)
lower_bound(----//----) -> връща указател
lower_bound връща указател към първия елемент по-голям или равен.
upper_bound връща указател към първия елемент който е строго по-голям.


double f(double);
double eps = 10e-9;
int binary_search (double start, double end, double f)
{
  while(end-start > eps)
  {
    double mid = start + (end - start) / 2 // хакерияяя
    double res = f(mid);
    if(res < val)
    {
      end = mid;
    } else start = mid;
  }
  return start;
}
Хубава практика е да разглеждаме интервалите които изследваме
като включително отляво и изключително от дясно: [1; 10) [10; 15)

================================
Задача 2: Intervals:

1. Начин - акумулативен масив.
Нека имаме масива:

1  2 3 4 5 6 7 8 9
7 10 3 5 5 8 2 1 9

Първо сортираме масива
1 2 3 5 5 7 8 9 10

1 2 -> 1 2
5 5 -> 5
3 9 ->
За да го направим по бързо
В новия масив sum[N ]ще пазим всички суми от 1 до до i  текущия
1 3 6 11 16 23 31 40 50
За да се сметнем сумата на елементите от 5 до 5 вземаме sum[5] - sum[4]
За да се сметнат сумата на 3 до 9; връщаме сумата на sum[9] - sum[3]

Общата формула
За да сметнем от i до j:
a[i] - A[ j - 1]

един if да го броим за нула.
============
2. Начин - бинарно индексно дърво

                        50(idx = 1)
            40(2)                         10(3)
     11(4)         29(5)          10(6)         0(7)
  3(8)  8(9)    12     17      10      0     0     0
1   2  3   5  5   7  8   9  10    0  0  0  0  0  0   0

Трябва да знаем броя елементите. Нека той е n. Използваме този брой, за да
намирим най близката степен на 2, която е по-малка или равна на n. Нека това число
го кръстим n2. Тогава целия масив ще е голям n2*2.

Подобно на heap баща ни се намира при делено на две parent(i) = 2*i;
Дали сме ляв или десен- четен(ляв) нечетен(десен) left(i) = i/2 right = i/2 +1

Размера N на целия масив е 32

Построяване на бинарно индексно дърво:
  for(int i = n2 - 1; i)
    a[i] = a[2 * i] + a[2 * i + 1]


int sum(int idx)
{
  idx += n2;
  int s = 0;
  while(idx > 1)
  {
    if(idx % 2 ==1) // проверяваме десен син ли е? Ако е десен прибавяме 11
      s += a[idx - 1];
    idx /2;
  }
}

При промяна на някой елемент се качваме нагоре и обновявава стойностите.
Корена никога не се използва пряко, но е хубаво да е обновен.

int sum(int idx, int numVal)
{
  idx += n2;
  a[idx] = newVal;
  int s = 0;
  while(idx > 1)
  {
    if(idx % 2 ==1) // проверяваме десен син ли е? Ако е десен прибавяме 11
        a[idx>>1] = a[idx] + a[idx^1]
        idx /= 2;
    idx /2;
  }
}

Побитови операции
=======================
14
1110

15
1111

idx^

shift- ваме
idx >> 1; ->  делим на две
idx << 1; ->  умножавем на две

Строим си празно дърво на което даваме. Сложност N log N
