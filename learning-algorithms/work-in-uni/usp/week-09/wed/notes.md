Има динамично RMQ- RMQ-то от понеделник, при кеото всичко е със сложност log N
Сложността за preprocessing e O(n), защото има 2N елемента.
Сложността за търсене е O(log N)

Има и друг вариант, който използва O(N log N) време за preprocessing, и няма да можем да променяме елементи.
Ползтата от новия метод е, че от логаритмичните заявки ще ги направим константно.

R[MAXN][LONGMAXN]

R[k][j] - пази стойността за RMQ в интервала от започващ от к и със дължина [k, k + 2 ^ j]]).
[k, k + 2^)= [k, k + 1) = [k, k];

Ще използваме схемата за динамично програмиране.
Имаме, че R[k][0] = k
R[k][j] =  R[k][j - 1], if V[R[k][j-1]] < V[R[k +  2 (j - 1)]]
           R[k + 2 ^ (j - 1)[j - 1], в противен случай


Намираме най-голямата степен на двойката, която е по малко от дължината на интервала.
Ще вземем просто два интер[]вала
Първия интервала ще започва от където дойде, но важно да свършва къде почва другия интервал
ВАжното е че двата интервала заедно, тяхното обединение ни е целия интервал, който търсим.

1 2 5 8 3 4 9 2И

----------------
```
__builtin_clz -> броя на започващите нули
__builtin_popcount -> броя от единици в двоично предствяне на число. Много е удобно да се
__builtin_ctz -> броя на зъвършващите нули
```

00000000000101101
---------------------------
LCA

Нека имаме  дърво, което е представано като спи
Обхождаме всички със дфс
Единицата се намира на ниво 0

1  2  7  2  8  2  1  3  4 |12  4  3  5  9 10|  9  5 11  5  3  6  3  1
0  1  2  1  2  1  0  1  2 | 3  2  1  2  3  4|  3  2  3  2  1  2  1  0

Нов масив, който показва индекса, където се среща за пръв път масива.
Чрез този масив намираме интервала върху който пускаме LCA
С това се свежда LCA до линейна сложност.
