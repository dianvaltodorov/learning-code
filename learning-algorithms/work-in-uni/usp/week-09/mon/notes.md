1.LCA task
------

O(n lg n)
O(lg n)


f(vr, k) -> по даден връх и по брой нива нагоре ни връща върха в който се озовавем.
Това може да се уксори като се предварително се преизчислят някои стойности.
Пазим ги тези всикчки числа. Това не е много ефективно но ще помним степените на двойката.
Ако ни кажат да се качим к стъпки нагоре и гледаме най-голямата степен на двойката, която влиза в степента.

f(15, 5) = f(4 1) = 2
f(13. 2^k) = f(f(13, 2^(k-1), 2^k-1))

Това става със аоя

dfs :     1 2 4 4 5 5 2 3 3 1
bracket:  [ [ [ ] [ ] ] [ ] ]
Това може да стане става със брояч. Помним първото и последното срещане

```
time = 0;
void dfs(root v)
{
  first_timep[vr] = time++;

  last_time[vr] = time++;
}

bool isParent(a , b)
{
  first_time[a] <= first_time[b] && last_time[a] >= first_time[b];

}
```

Търсим последния връх който

6 4 2 1
0 0 1 1

_  _  _  _  _
Правим нещо като binarySearch() по върховете.
Задачи:
http://acm.ro/

2. n <= 10^6,  числа до 10^9
  2 <= k <= 20^6
  A[1], A[2], A[3], A[4], A[5]

  k = 2;
  Ако пазим самите бройки ще ни излезе от memory limit-a.
  Знаем че за всички числа броя на срещания се делят на k. Има едно, чиито брой на срещания не се дели на к. Да се намерим това число.

  Трябва да използваме xor. Xor-ваме ги две по две всчки, които се срещат четен брой пъти ще станат, а това които не се срещат четен брой пъти ще остане като валиден отговор
  3 3 3 3 4 4 4 5 5 5 5

  Записваме си го в двоично предствяне. Там където за i-тото число на входа, да бъде във двоичен запис.
  A[i] =(a[i][0], a[1][1], a[1][1], ... a[1][31])
  Намираме всички

  Имаме само този само 1 масив не матрица

  3, 3, 3, 4, 4, 5, 5, 5

  3 -> 011
  4 -> 100
  5 -> 101

3  3
  +1  +1
  +1  +1
  +1  +1
      +1
      +1
  +1        +1
  +1        +1
  +1        +1
   3  6     5

  Остават битове на числото, което не се дели на к


3.Нок - най малко общо кратно
  НОД -
  a, b

  НОК(a+ n, b + n) =  (a + n)(b + n) / НОД (a + n, b + n)

  Интересуват ни ст на

  GCD(x, y) = GCD(x - y, y)
  GCD(a + n, b + n) = GCD( (a + n) - (b + n), b + n) = GCD(a - b, b + n)

  d / a + n => n = -a mod d
  d / b + n => n = -b mod d


  for(int i = 2; i * i < = w; ++i)
    if(w % i == 0) cout << i << " " << w / i << endl;


=====
e-maxx.com
