Двоично Тръсене

Работим над масив с n елемента.


while(e-b > 1)
{
  m= (b + e - 1)%2;
  if(f(m)==0)
  {
    b = m + 1;
  } else{
    e = m + 1;
  }
  return l;
}

Така дифенинарана функцията работи над дискретни стойности. В случай че работим с реални числа
трябва да се внимава много.

while(abs(е - b) > 0)
{
  m = (b + e)/2;
}

можем да използваме цикъл с for(i = 0; i >= 64; ++i)

Нека държим стойностите в масив int mas[N], n;
Най трики случая е когато остане масив от два елемента

Варианти за двоична търсене
Ternary Search
Hill Climbing

Ternary search - работи над интервал, който знаем начало и край. Мое да е дискретна функция
но в повечето случаи е непрекъснат интервал f(x)  принадлежи на интервала [b; a]
Вместо да се вземе средата вземаме двата интервала.


m1  = (2b + e)/3
m2  = (b + 2e)/3
if f(m1) > f(m2)
  [b m1]
else
  [m1 e]

ternary  взема от интервала 2/3
binary взема от интервала 1/2

Разстоянието до окръност.

интерполационно търесене.

sort(mas, mas + n)
sort(mas, mas )
compare function

typedef char* pch;
typedef pair<int, string> pis;
typedef vector <pis> vpis;
