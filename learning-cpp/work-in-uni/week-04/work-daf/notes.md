Табулация
За да обработваме файл, трябва да сме наясно какъв е формата му и да знаем. Оператора за вход >> чете до бяло поле.
Ако имаме име с бяло поле(име и фамилия)
За вход използваме getline и getline
Оператораът за изход << записва във файл
Функциите за двоичен режим и за текстов файл е различен
четене от двоичен `ifstream("име_на_потока ". ios::binary, ios::in);`

писане от двоичен `ofstream("име_на_потока ". ios::binary, ios::out);` Това ще презапише файла. Трябва да използваме други флагове ios::ate(в края), ios::app(прикачи)

Ако имаме 12 се записва в текстов файл 1(ASCII код), 2(ASCII код).
Четенето се прави с `read(const char * size_t)`
Хубавото на двоичните файлове е че записваме файлове с размер.
Искам да скоча на третия, знаем размерите на елементите и ако му кажа, че искам да взема третия мога да го напарвя.Текстовия файл го почваме отначалото и го обработваме отначалото.
Двоичните файлове елементите скача напред и назад
Когато имаме файл за четене, това означава че имаме get указател.
Когато имаме файл за писане, това означава, че имаме put указател.
При fstream се прави
Не си пречат.

```
file.seekg(0, ios::beg);
file.seekg(0, ios::end);
file.seekg(0, ios::end);
file.seekg(-k * size, ios::cur);
file.seekg(k * size, ios::cur);
file.tellg();

file.seekp(0, ios::beg);
file.seekp(0, ios::end);
file.seekp(0, ios::end);
file.seekp(-k * size, ios::cur);
file.seekp(k * size, ios::cur);
file.tellp();
```

В двоичен файл не записваме съдържание на указател. Динамична памет не се записва. Всяко име е с потенциално различна дължина, не може да скачаме. В едните данни името е 15 символа. За да направим скок всички елементи трябва да бъдат с един и същ размер. Трябва да налеем самите данни. Не можем да гарантираме, че там ще се намират нещата.
Ако записваме нещо с променлива дължина, някъде преди това трябва да вкараме размера на дданите. Имаме двоичен файл, отворен за извеждане. Искаме да запишем цяло число в него. Имаме си променлива, в която сме намерили дължината на името.
file.write()

```
size_t len = strlen(clientName);
file.write((const char *) &len, sizeof(len));
```
Тво взема указател към данните &len.
Кастваме този указател към `(const char *)`, за да излъжем функцията.
Указваме колко да четем.

Това няма да работи с динамична памет.
Ако имаме статично зададене полета на структурата, можем спокойно да пишем. Винаги си ги имам позициите без проблеми. Трябва изрично да си пооправим нещата, в случай че имаме нужда


```
BankAccount ba;
file.write((const char *) &ba, sizeof(ba));
```
