разделна компилация препроцесор
#include - копира съдържанието на файла, който се include-ва, слага съдържанието на файла
compilation unit(A.cpp, B.h, C.h) единица, която се компилира

```
#include "B.h"
...
#include "C.h"
```

На мястото на #include "B.h" се слага съдържанието на файла "B.h"
Минаве се през cpp, подменя и се получава ново цпп, по голямо от предишното с добавено на файл.
---------------------
Пример:
```
във файл 1.h има
"int main"

във файл 2.h има
"("

във файл 3.h има
"){return"

във файл 4.h има
"}"
```


```
#include "1.h"
#include "2.h"
#include "3.h"
0;
#include "4.h"
```
след като мине препроцесора

```
int main
(
)
{return
0;
}
```
Просто пльосва съдържанието.Всяка директива трябва да е на един ред. Препроцесор
са всички неща които почват с диез.

------------------

#include <iostream>

Файлът iostream не сме го писали.Когато се include с човки, търси в системните
директории и после в нашите файлове.Когато се include с кавички, търси в нашия
проект и после в и после в системните файлове.Ако имаме и собствен файл с име
iostream, тогава първо#include "iostream" - ще включи наш

-----------------------

#define e макрос
#define X
дефинират се с главни букви, за да се различват
#define X 2+2
ако имаме програма
```
int main()
{
	int a = X;
}
```
Препроцесора минава и навсякъде, където се среща X се подменя с 2+2. След като
е минал препроцесора, тогава програмата изглежда по следния начин.

```
int main ()
{
	int a = 2+2;
}
```
Има вариант в който не е удачно
```
const int X = 2+2;
int main()
{
	int a = 2*X; // 8
}
```
Същото тяло на функция с препроцесор, ще подмени Х със 2+2, реда на изчисление ще е по друг, ст
```
int main()
{
	int a = 2*2+2;
}
```
```
#define F(x, y) x + 2 - y
int main()
{
	int a = F(2+2, 3*3*3); // препроцесора подменя и компилаторът ще види следното 2+2 + 2 - 3*3*3
}
```
Прилича на функция, но не, компилаторът няма да види такива работи. Има готови
дефинира макроси, които винаги ги има в една програма.

```
__LINE__ - текущият ред във файла
__FILE__ - името на текущия файл
__DATE__ - датата, дата, стринг
__TIME__ - времете, часа, стринг
```
```
int main()
{
	int a = __LINE__; // в а се записва текущия ред. цяло число
	cout << "Compiled on " <<__DATE__ << "at << __Time__ << "\n";
}
```
---------

`assert` - много фубаво нещо.
Прави програма и му казвам я въведи на колко си години. И той въвежда -3. Ако са грешки на потребителя така ги опрвяме.
Има грешки на програмиста. Правим функция, която смята корен квадратен. Тя не трябва да смята с отрицателни числа.
Функцията се казва mysqrt
С assert програмиста се улавят грешки на програмиста. Assert работи така - има нещо и утвърждавам, че това нещо е вярно

```
double mysqrt(douvble x)
{
	assert(x >= 0)
	// смята
}
```

Програмата стига до реда със assert и то гръмва. Програмата казва проверява се
условие и програмата спира.Човек как може да си напише такова нещо като assert.
Assert знае как е написан входа.Assert работи с кода. Той работи с макрос.
Ако решим да го пишем без assert, тогава кода ни ще изглежда по скледния начин
```
if(!(x>=0))
{
	cout << "Assertion failed!"
	<< "x >= 0"
	<< "in File"
	<< __FILE___
	<< ", line"
	<< __LINE__
        << "\n";
}
```
Ако трябва всеки път да го пишем всеки път
Препроцесора е винаги e на един. Гореописания код е на 7; Можем да го напишем на 1, но няма да е четимо
int a \
= 5

Този проблем се решава с добавяне на една наклонена черта.
```
if(!(x>=0))
{
	cout << "Assertion failed!" \
	<< "x >= 0" \
	<< "in File" \
	<< __FILE___\
	<< ", line"\
	<< __LINE__\
        << "\n";\
}
```

```
int a\
	=5;
```

Ако сложим на новия ред интервали, табулаци. няма да е проблем. Препроцесара го залепя на предишния ред и работи.

Красиво
```
if(!(x>=0))
{
	cout << "Assertion failed!" \
	<< "x >= 0" 	            \
	<< "in File"	            \
	<< __FILE___		    \
	<< ", line" 	            \
	<< __LINE__		    \
        << "\n";	    	    \
}
```

```
#define assert(expr)\
	if(expr)
	{
		cout << "Assertion failed!" \
		<< "x >= 0" 	            \
		<< "in File"	            \
		<< __FILE___		    \
		<< ", line" 	            \
		<< __LINE__		    \
	        << "\n";	    	    \
	}
```

```
double MySqrt(double value)
{
	assert(x >= 0)
}
```
Компилаторът ще види

```
double MySqrt(double value)
{
	if(!(x>=0))
	{
		cout << "Assertion failed!" \
		<< #expr	            \
		<< "in File"	            \
		<< __FILE___		    \
		<< ", line" 	            \
		<< __LINE__		    \
       		 << "\n";	    	    \
	}
}
```
#еxpr взима това нещо и го прави на низ
в резлутат на което ще се получи ефектът, който ние искаме. Така потребителя ще види това, което искаме. На всяко от тия места ще тсои такъв низ
Това го има на готово

; - празния оператор. При писането на assert не е нужно да я слагаме. Може се ползва за откриване на грешка.

Това разкрива повече от което бихме искали да знаем.Може да има някой, който знае.
Когато ние тестваме и дебъгваме
Решението можем да използваме #DEBUG макрос

#define _SHTE_SE_DEBUGVA

#ifdef _SHTE_SE_DEBUGVA
#define assert(expr)\
	if(expr)
	{
		cout << "Assertion failed!" \
		<< "x >= 0" 	            \
		<< "in File"	            \
		<< __FILE___		    \
		<< ", line" 	            \
		<< __LINE__		    \
	        << "\n";	    	    \
	}
#else
#define assert(expr)
#endif

В дебъг режим можем да слагаме колкото си искаме #assert можем да правим колкото си искаме проверки.
Вградениея assert.h има ли такава функционалност.

#define NDEBUG
По подразбиране assert си работи
При техния
#ifndef NDEBUG
ifdef = if define(NDEBUG)
ifndef =! if define (NDEBUG)

За да дефинираме макроси се прави define.
Пишем си нашето приложение и сме нашарили версията с много NDEBUG
#define NDEBUG

-------------------
```
int vst1 = 5;
int var2 = 10;
int a3 = 100;
#define ZERO (name , index)
``
ZERO(var, 1) - името на променлива и името и
Искаме това нещо на това място да се запише
ZERO(name, index),
и искаме да подадем ZERO(var, 1) и то да върне var1
#define ZERO (name, index) name##index = 0 - два диеза ги слепва

assert е реален пример защо се използва препроцесора.
Препроцесора е направен за да генерира вместо нас код.
Шаблони за дизайн.
Ключовото е че ще се замести
Може да се сложи рекурся, един макрос може да извика себе си и така се получава.

Можем да вземем името на променлива с макрос
Един диез и два диеза работят с препроцесор
#define NAME(a) #a
cout << NAME (x); // връща X;
Взема всичко от скобите и го прави на string
cout << NAME("Hello\n") // връща "\"Hello\"
По умно е защото escape-ва. На само ще се погрежи за специалните символи

#pragma - директива, с която да настроим компилатора.
#pragmа - голяма част от директивите са специфични за неговия си компилатор

#pragme

A.h
void f(int x);
разделна компилация
Нищо не пречи в един файл, който се казва да речем cpp
```
#include "A.h"
#include "A.h"
```
Тогава ако направим компилаторът ще види
```
void f(int x)
void f(int x)
```
Което ще направи грешка. Проблемът има решение.
#pragma once. Ако това ни е първи ред във файл, това означава, че този header файл може да се включва само веднъж, проверя дали вече го включило и го прескача.
#pragma once ни пази.


Поддържа се таблица с включени класове и помни.
За него файлвоете съвпадат само с името си.С гардове. За всеки хедър файл се прави това нещо.

Препроцесорът е нещо, което се използва за различни неща.
Има различни приложения.
